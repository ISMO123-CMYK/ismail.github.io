<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Government Pose Tracking System</title>
<style>
  *{box-sizing:border-box;margin:0;padding:0}
  html,body,#root{height:100%}
  body{font-family:Segoe UI, Tahoma, Geneva, Verdana, sans-serif;background:#000;color:#fff;overflow:hidden}
  #root{width:100vw;height:100vh;position:relative}

  /* Video Feed - Bottom Left */
  #video-container{position:absolute;bottom:16px;left:16px;width:320px;height:240px;background:#111;border-radius:8px;z-index:3;overflow:hidden}
  video{width:100%;height:100%;object-fit:cover}

  /* Main Model Area */
  .model-container{position:absolute;top:0;left:0;width:100%;height:100%;display:flex}
  .model-canvas{flex:1;height:100%;position:relative}

  /* Skeleton Canvas */
  .skeleton-canvas{background:#111}

  /* Robot Canvas */
  .robot-canvas{background:linear-gradient(135deg, #0c0c0c, #1a1a2e)}

  /* UI Controls */
  .status{position:absolute;top:16px;left:16px;background:rgba(0,0,0,0.65);padding:10px 16px;border-radius:20px;z-index:10;font-size:14px}
  .status-indicator{display:inline-block;width:8px;height:8px;border-radius:50%;margin-right:8px;background:#4caf50}

  .controls{position:absolute;bottom:16px;left:16px;display:flex;gap:12px;z-index:10}
  .btn{padding:10px 16px;border-radius:25px;border:none;cursor:pointer;background:linear-gradient(45deg,#667eea,#764ba2);color:#fff;font-weight:600;transition:all .2s ease;font-size:14px;box-shadow:0 0 20px rgba(102,126,234,0.3)}
  .btn:hover{transform:translateY(-2px);box-shadow:0 8px 25px rgba(102,126,234,0.4)}
  .btn.primary{background:linear-gradient(45deg,#4caf50,#45a049);box-shadow:0 0 20px rgba(76,175,80,0.3)}
  .btn.danger{background:linear-gradient(45deg,#f44336,#d32f2f);box-shadow:0 0 20px rgba(244,67,54,0.3)}
  .btn:disabled{background:#666;cursor:not-allowed;transform:none;box-shadow:none}

  /* Guidelines Panel */
  .guidelines-panel{position:absolute;top:50%;right:16px;transform:translateY(-50%);background:rgba(0,0,0,0.8);backdrop-filter:blur(10px);padding:20px;border-radius:12px;border:1px solid rgba(255,255,255,0.1);max-width:300px;max-height:80vh;overflow-y:auto;z-index:9;font-size:12px;line-height:1.4}
  .guidelines-panel h3{margin:0 0 12px 0;font-size:14px;color:#667eea;text-align:center}
  .guidelines-panel ul{margin:0;padding-left:16px}
  .guidelines-panel li{margin-bottom:6px;color:#e8e8e8}
  .guidelines-panel .toggle-btn{position:absolute;top:10px;right:10px;background:none;border:none;color:#fff;font-size:18px;cursor:pointer}

  /* Neon animations */
  @keyframes neon-pulse {
    0%, 100% { filter: drop-shadow(0 0 5px currentColor); }
    50% { filter: drop-shadow(0 0 20px currentColor); }
  }
</style>
</head>
<body>
<div id="root"></div>

<script src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5/pose.js" crossorigin="anonymous"></script>

<script type="text/babel">
const { useState, useEffect, useRef, useCallback } = React;
const { createRoot } = ReactDOM;

const POSE_CONNECTIONS = [
  [0, 1], [0, 2], [1, 3], [2, 4], [0, 5], [0, 6], // head
  [5, 7], [7, 9], [6, 8], [8, 10], [5, 6], [5, 11], [6, 12], // upper body
  [11, 12], [11, 13], [13, 15], [12, 14], [14, 16], // arms
  [11, 23], [12, 24], [23, 24], [23, 25], [24, 26], // torso hips
  [25, 27], [26, 28] // legs
];

function App() {
  const videoRef = useRef(null);
  const skeletonCanvasRef = useRef(null);
  const robotCanvasRef = useRef(null);
  const streamRef = useRef(null);
  const poseRef = useRef(null);
  const cameraRef = useRef(null);
  const prevLandmarksRef = useRef(null);
  const animationIdRef = useRef(null);
  
  const [streaming, setStreaming] = useState(false);
  const [error, setError] = useState('');
  const [showGuidelines, setShowGuidelines] = useState(true);
  const [poseDetected, setPoseDetected] = useState(false);
  
  // Smoothing factor for animation
  const SMOOTHING = 0.3;
  const CANVAS_WIDTH = window.innerWidth / 2;
  const CANVAS_HEIGHT = window.innerHeight;

  const generateSmoothedLandmarks = useCallback((newLandmarks) => {
    if (!prevLandmarksRef.current) {
      prevLandmarksRef.current = newLandmarks;
      return newLandmarks;
    }
    const smoothed = newLandmarks.map((lm, i) => {
      const prev = prevLandmarksRef.current[i];
      return {
        x: prev ? prev.x + SMOOTHING * (lm.x - prev.x) : lm.x,
        y: prev ? prev.y + SMOOTHING * (lm.y - prev.y) : lm.y,
        z: lm.z,
        visibility: lm.visibility
      };
    });
    prevLandmarksRef.current = smoothed;
    return smoothed;
  }, []);

  const drawSkeleton = useCallback((ctx, landmarks, canvasWidth, canvasHeight) => {
    ctx.clearRect(0, 0, canvasWidth, canvasHeight);
    ctx.strokeStyle = '#00ff00';
    ctx.lineWidth = 3;
    ctx.shadowColor = '#00ff00';
    ctx.shadowBlur = 10;
    ctx.animation = 'neon-pulse 1s infinite';

    POSE_CONNECTIONS.forEach(([i, j]) => {
      const p1 = landmarks[i];
      const p2 = landmarks[j];
      if (p1.visibility > 0.5 && p2.visibility > 0.5) {
        ctx.beginPath();
        ctx.moveTo(p1.x * canvasWidth, p1.y * canvasHeight);
        ctx.lineTo(p2.x * canvasWidth, p2.y * canvasHeight);
        ctx.stroke();
      }
    });

    // Draw landmarks as small green dots
    landmarks.forEach((lm) => {
      if (lm.visibility > 0.5) {
        ctx.beginPath();
        ctx.arc(lm.x * canvasWidth, lm.y * canvasHeight, 4, 0, 2 * Math.PI);
        ctx.fillStyle = '#00ff00';
        ctx.fill();
      }
    });
    ctx.shadowBlur = 0;
  }, []);

  const drawRobot = useCallback((ctx, landmarks, canvasWidth, canvasHeight) => {
    ctx.clearRect(0, 0, canvasWidth, canvasHeight);
    
    // Robot body structure with neon cyberpunk style
    ctx.strokeStyle = '#ff00ff';
    ctx.lineWidth = 5;
    ctx.shadowColor = '#ff00ff';
    ctx.shadowBlur = 15;

    // Head (enhanced with face details)
    const nose = landmarks[0];
    const leftEye = landmarks[1];
    const rightEye = landmarks[2];
    if (nose && leftEye && rightEye && nose.visibility > 0.5) {
      // Robot head circle
      ctx.beginPath();
      ctx.arc(nose.x * canvasWidth, (nose.y - 0.1) * canvasHeight, 0.08 * canvasHeight, 0, 2 * Math.PI);
      ctx.stroke();
      // Eyes as glowing orbs
      ctx.beginPath();
      ctx.arc(leftEye.x * canvasWidth, leftEye.y * canvasHeight, 0.015 * canvasHeight, 0, 2 * Math.PI);
      ctx.fillStyle = '#00ffff';
      ctx.shadowColor = '#00ffff';
      ctx.shadowBlur = 20;
      ctx.fill();
      ctx.beginPath();
      ctx.arc(rightEye.x * canvasWidth, rightEye.y * canvasHeight, 0.015 * canvasHeight, 0, 2 * Math.PI);
      ctx.fill();
      // Mouth line
      const mouthTop = landmarks[9]; // approx mouth top
      const mouthBottom = landmarks[10];
      if (mouthTop && mouthBottom) {
        ctx.beginPath();
        ctx.moveTo(mouthTop.x * canvasWidth, mouthTop.y * canvasHeight);
        ctx.lineTo(mouthBottom.x * canvasWidth, mouthBottom.y * canvasHeight);
        ctx.stroke();
      }
      ctx.shadowBlur = 0;
    }

    // Ears approx from pose (landmarks 7,8 for outer ears)
    const leftEar = landmarks[7];
    const rightEar = landmarks[8];
    if (leftEar && rightEar && leftEar.visibility > 0.5) {
      ctx.beginPath();
      ctx.arc(leftEar.x * canvasWidth, leftEar.y * canvasHeight, 0.02 * canvasHeight, 0, 2 * Math.PI);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(rightEar.x * canvasWidth, rightEar.y * canvasHeight, 0.02 * canvasHeight, 0, 2 * Math.PI);
      ctx.stroke();
    }

    // Neck
    const leftShoulder = landmarks[11];
    const rightShoulder = landmarks[12];
    const neckY = (leftShoulder.y + rightShoulder.y) / 2 * canvasHeight;
    if (nose && leftShoulder && rightShoulder) {
      const neckStartY = nose.y * canvasHeight + 0.05 * canvasHeight;
      ctx.beginPath();
      ctx.moveTo(nose.x * canvasWidth, neckStartY);
      ctx.lineTo((leftShoulder.x + rightShoulder.x)/2 * canvasWidth, neckY);
      ctx.stroke();
    }

    // Torso
    const leftHip = landmarks[23];
    const rightHip = landmarks[24];
    if (leftShoulder && rightShoulder && leftHip && rightHip) {
      // Left side
      ctx.beginPath();
      ctx.moveTo(leftShoulder.x * canvasWidth, leftShoulder.y * canvasHeight);
      ctx.lineTo(leftHip.x * canvasWidth, leftHip.y * canvasHeight);
      ctx.stroke();
      // Right side
      ctx.beginPath();
      ctx.moveTo(rightShoulder.x * canvasWidth, rightShoulder.y * canvasHeight);
      ctx.lineTo(rightHip.x * canvasWidth, rightHip.y * canvasHeight);
      ctx.stroke();
      // Bottom bar
      ctx.beginPath();
      ctx.moveTo(leftHip.x * canvasWidth, leftHip.y * canvasHeight);
      ctx.lineTo(rightHip.x * canvasWidth, rightHip.y * canvasHeight);
      ctx.stroke();
    }

    // Arms
    if (leftShoulder && landmarks[13] && landmarks[15]) {
      ctx.beginPath();
      ctx.moveTo(leftShoulder.x * canvasWidth, leftShoulder.y * canvasHeight);
      ctx.lineTo(landmarks[13].x * canvasWidth, landmarks[13].y * canvasHeight);
      ctx.lineTo(landmarks[15].x * canvasWidth, landmarks[15].y * canvasHeight);
      ctx.stroke();
    }
    if (rightShoulder && landmarks[14] && landmarks[16]) {
      ctx.beginPath();
      ctx.moveTo(rightShoulder.x * canvasWidth, rightShoulder.y * canvasHeight);
      ctx.lineTo(landmarks[14].x * canvasWidth, landmarks[14].y * canvasHeight);
      ctx.lineTo(landmarks[16].x * canvasWidth, landmarks[16].y * canvasHeight);
      ctx.stroke();
    }

    // Legs
    if (leftHip && landmarks[25] && landmarks[27]) {
      ctx.beginPath();
      ctx.moveTo(leftHip.x * canvasWidth, leftHip.y * canvasHeight);
      ctx.lineTo(landmarks[25].x * canvasWidth, landmarks[25].y * canvasHeight);
      ctx.lineTo(landmarks[27].x * canvasWidth, landmarks[27].y * canvasHeight);
      ctx.stroke();
    }
    if (rightHip && landmarks[26] && landmarks[28]) {
      ctx.beginPath();
      ctx.moveTo(rightHip.x * canvasWidth, rightHip.y * canvasHeight);
      ctx.lineTo(landmarks[26].x * canvasWidth, landmarks[26].y * canvasHeight);
      ctx.lineTo(landmarks[28].x * canvasWidth, landmarks[28].y * canvasHeight);
      ctx.stroke();
    }

    // Robot joints as glowing dots
    landmarks.forEach((lm, i) => {
      if (lm.visibility > 0.5 && [0,11,12,23,24,13,14,25,26].includes(i)) { // key joints
        ctx.beginPath();
        ctx.arc(lm.x * canvasWidth, lm.y * canvasHeight, 8, 0, 2 * Math.PI);
        ctx.fillStyle = '#ffff00';
        ctx.shadowColor = '#ffff00';
        ctx.shadowBlur = 15;
        ctx.fill();
      }
    });
    ctx.shadowBlur = 0;
  }, []);

  const onPoseResults = useCallback((results) => {
    if (results.poseLandmarks) {
      setPoseDetected(true);
      const smoothedLandmarks = generateSmoothedLandmarks(results.poseLandmarks);

      // Draw on skeleton canvas (left)
      if (skeletonCanvasRef.current) {
        const ctx = skeletonCanvasRef.current.getContext('2d');
        drawSkeleton(ctx, smoothedLandmarks, CANVAS_WIDTH, CANVAS_HEIGHT);
      }

      // Draw on robot canvas (right)
      if (robotCanvasRef.current) {
        const ctx = robotCanvasRef.current.getContext('2d');
        drawRobot(ctx, smoothedLandmarks, CANVAS_WIDTH, CANVAS_HEIGHT);
      }
    } else {
      setPoseDetected(false);
      if (skeletonCanvasRef.current) {
        const ctx = skeletonCanvasRef.current.getContext('2d');
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      }
      if (robotCanvasRef.current) {
        const ctx = robotCanvasRef.current.getContext('2d');
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      }
    }
  }, [generateSmoothedLandmarks, drawSkeleton, drawRobot]);

  // Start camera
  const startCamera = async () => {
    try {
      setError('');
      const stream = await navigator.mediaDevices.getUserMedia({ 
        video: { width: 640, height: 480 }
      });
      streamRef.current = stream;
      const video = videoRef.current;
      video.srcObject = stream;
      
      await new Promise(resolve => {
        video.onloadedmetadata = () => {
          video.play();
          resolve();
        };
      });
      
      setStreaming(true);

      // Init MediaPipe Pose
      poseRef.current = new Pose({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5/${file}`
      });
      poseRef.current.setOptions({
        modelComplexity: 1,
        smoothLandmarks: true,
        enableSegmentation: false,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
      });
      poseRef.current.onResults(onPoseResults);

      cameraRef.current = new Camera(video, {
        onFrame: async () => {
          await poseRef.current.send({ image: video });
        },
        width: 640,
        height: 480
      });
      cameraRef.current.start();
    } catch (err) {
      setError('Camera access denied. Please allow camera access.');
      console.error('Camera error:', err);
    }
  };

  // Stop camera
  const stopCamera = () => {
    if (streamRef.current) {
      streamRef.current.getTracks().forEach(track => track.stop());
      streamRef.current = null;
    }
    if (cameraRef.current) {
      cameraRef.current.stop();
    }
    if (poseRef.current) {
      poseRef.current.close();
    }
    setStreaming(false);
    setPoseDetected(false);
    prevLandmarksRef.current = null;
    if (skeletonCanvasRef.current) {
      const ctx = skeletonCanvasRef.current.getContext('2d');
      ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    }
    if (robotCanvasRef.current) {
      const ctx = robotCanvasRef.current.getContext('2d');
      ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    }
  };

  useEffect(() => {
    // Resize canvases on window resize
    const resize = () => {
      if (skeletonCanvasRef.current) {
        skeletonCanvasRef.current.width = window.innerWidth / 2;
        skeletonCanvasRef.current.height = window.innerHeight;
      }
      if (robotCanvasRef.current) {
        robotCanvasRef.current.width = window.innerWidth / 2;
        robotCanvasRef.current.height = window.innerHeight;
      }
    };
    window.addEventListener('resize', resize);
    resize();
    return () => window.removeEventListener('resize', resize);
  }, []);

  useEffect(() => {
    return () => stopCamera();
  }, []);

  if (error) {
    return (
      <div style={{display:'flex', alignItems:'center', justifyContent:'center', height:'100vh', background:'#000', color:'#fff', fontSize:'18px'}}>
        <div>{error} <button className="btn primary" onClick={startCamera} style={{marginLeft:'10px'}}>Retry</button></div>
      </div>
    );
  }

  return (
    <div style={{width:'100vw',height:'100vh',position:'relative'}}>
      {/* Model Containers Side by Side */}
      <div className="model-container">
        <canvas ref={skeletonCanvasRef} className="model-canvas skeleton-canvas" />
        <canvas ref={robotCanvasRef} className="model-canvas robot-canvas" />
      </div>

      {/* Small Video Feed Bottom Left */}
      <div id="video-container">
        <video ref={videoRef} autoPlay playsInline muted />
      </div>

      {/* Status */}
      <div className="status">
        <span className="status-indicator"></span>
        {streaming ? (poseDetected ? 'Pose Tracked' : 'Searching Pose') : 'Camera Off'}
      </div>

      {/* Controls */}
      <div className="controls">
        {!streaming ? (
          <button className="btn primary" onClick={startCamera}>
            📹 Start Tracking
          </button>
        ) : (
          <button className="btn danger" onClick={stopCamera}>
            ⏹️ Stop Tracking
          </button>
        )}
      </div>

      {/* Guidelines */}
      {showGuidelines && (
        <div className="guidelines-panel">
          <button className="toggle-btn" onClick={() => setShowGuidelines(false)}>✕</button>
          <h3>Pose Tracking Guidelines</h3>
          <ul>
            <li>Stand in full view of the camera</li>
            <li>Keep good lighting</li>
            <li>Move slowly for smooth tracking</li>
            <li>Left: Raw Skeleton | Right: Robot Model</li>
            <li>Watch the neon transformations!</li>
          </ul>
        </div>
      )}
    </div>
  );
}

const root = createRoot(document.getElementById('root'));
root.render(<App />);
</script>
</body>
</html>
